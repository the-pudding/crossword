{"version":3,"sources":["styles/styles.js","components/charts/crossword/context.js","components/charts/crossword/Cell.js","components/charts/crossword/Clue.js","components/charts/crossword/DirectionClues.js","components/charts/crossword/util.js","components/charts/crossword/Crossword.js","components/charts/crossword/CrosswordChart.jsx","styles/colors.js","components/utils.js","components/charts/WaffleChart.jsx","components/story-sections/IntroPuzzle.jsx","components/story-sections/Intro.jsx","App.js","index.js"],"names":["GlobalStyle","createGlobalStyle","StoryTitle","styled","div","h1","Prose","p","ScrollyStep","CrosswordWaffleWrapper","WaffleChartBounds","WaffleChartWrapper","Block","props","color","WaffleChartLabel","Percentage","CrosswordContext","React","createContext","focused","selectedDirection","selectedNumber","CrosswordSizeContext","cellSize","cellPadding","cellInner","cellHalf","fontSize","Cell","cellData","onClick","focus","highlight","colorOverride","useContext","ThemeContext","cellBackground","cellBorder","textColor","numberColor","focusBackground","highlightBackground","handleClick","useCallback","event","preventDefault","row","col","guess","number","x","y","style","cursor","width","height","fill","stroke","strokeWidth","textAnchor","dominantBaseline","defaultProps","ClueWrapper","attrs","className","correct","Clue","direction","children","onClueSelected","aria-label","DirectionClues","clues","toUpperCase","map","clue","key","undefined","directionInfo","across","primary","orthogonal","down","bothDirections","Object","keys","isAcross","otherDirection","calculateExtents","data","dir","primaryMax","orthogonalMax","entries","forEach","info","answer","length","emptyCellData","used","locked","fillClues","gridData","rowStart","colStart","i","push","sort","byNumber","createGridData","acrossMax","downMax","size","Math","max","values","Array","r","c","createEmptyGrid","a","b","Number","parseInt","loadGuesses","storageKey","localStorage","window","saveRaw","getItem","guesses","val","split","deserializeGuesses","JSON","parse","defaultTheme","columnBreakpoint","gridBackground","OuterWrapper","theme","GridWrapper","CluesWrapper","Crossword","forwardRef","ref","onCorrect","onLoadedCorrect","onCrosswordCorrect","onCellChange","useStorage","colorCode","useState","setSize","setGridData","setClues","setFocused","focusedRow","setFocusedRow","focusedCol","setFocusedCol","currentDirection","setCurrentDirection","currentNumber","setCurrentNumber","bulkChange","setBulkChange","checkQueue","setCheckQueue","crosswordCorrect","setCrosswordCorrect","inputRef","useRef","contextTheme","getCellData","outOfBounds","setCellCharacter","char","cell","produce","draft","notifyCorrect","setTimeout","requestAnimationFrame","checkCorrectness","find","useEffect","every","clueInfo","current","moveTo","directionOverride","candidate","moveRelative","dRow","dCol","moveForward","moveBackward","handleSingleCharacter","handleInputKeyDown","ctrlKey","altKey","metaKey","other","handleInputChange","target","value","substring","loadedCorrect","correctAnswers","num","findCorrectAnswers","reduce","memo","memoInner","serializeGuesses","saveData","date","Date","now","setItem","stringify","saveGuesses","handleCellClick","handleInputClick","handleClueSelected","useImperativeHandle","reset","rowData","removeItem","fillAllAnswers","isCrosswordCorrect","context","finalTheme","cells","Provider","margin","padding","position","viewBox","type","onKeyDown","onChange","autoComplete","spellCheck","autoCorrect","top","left","textAlign","backgroundColor","caretColor","border","displayName","CrosswordChart","showAnswers","crosswordRef","confetti","COLORS","white","poc","man","woman","nonbinary","createMarkup","content","__html","addColorsToData","metric","updatedData","acrossKeys","_","downKeys","WaffleChart","title","colors","changeMetric","colorLookup","setColorLookup","roundedData","setRoundedData","arr","off","acc","round","chain","sortBy","roundData","colorOptions","d","floor","random","toString","updatedColorLookup","countTo100","groupPercent","groupNum","range","marginBottom","marginLeft","marginTop","toLowerCase","tempData","1","race","gender","2","3","4","IntroPuzzle","stepIndex","setStepIndex","setMetric","display","flexDirection","alignItems","copy","opacity","pick","first","raceGenderBreakdown","filter","decade","onStepEnter","debug","offset","introSteps","text","dangerouslySetInnerHTML","Intro","introProse","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b8ee1fd3.chunk.js","sourcesContent":["import styled, { createGlobalStyle } from \"styled-components\";\n\nexport const GlobalStyle = createGlobalStyle`\n  body {\n    font-family: Rubik, sans-serif;\n    background-color: white;\n    color: black;\n  }\n`;\n\nexport const LineChartWrapper = styled.div`\n  height: 500px;\n`;\n\nexport const StoryTitle = styled.h1`\n  text-align: center;\n`;\n\nexport const Prose = styled.p`\n  max-width: 40rem;\n  margin: 0 auto;\n  padding: 1rem;\n`;\n\nexport const ScrollyStep = styled.div`\n  margin: 50vh 0;\n  border: 1px solid gray;\n  padding: 15px;\n  z-index: 1000;\n  background: white;\n  width: 600px;\n  text-align: center;\n`;\n\nexport const CrosswordWaffleWrapper = styled.div`\n  margin-top: 100px;\n  margin-bottom: 100px;\n  position: sticky;\n  top: 100px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n`;\n\nexport const WaffleChartBounds = styled.div`\n  display: flex;\n  width: 120px;\n  height: 120px;\n  flex-wrap: wrap;\n  &:hover {\n    cursor: pointer;\n  }\n`;\n\nexport const WaffleChartWrapper = styled.div`\n  margin-top: 10px;\n  margin-bottom: 10px;\n  display: flex;\n`;\n\nexport const Block = styled.div`\n  height: 10px;\n  width: 10px;\n  margin: 1px;\n  background: ${(props) => props.color};\n`;\n\nexport const WaffleChartLabel = styled.div`\n  color: ${(props) => props.color};\n`;\n\nexport const Percentage = styled.div`\n  font-weight: bold;\n  font-size: 36px;\n`;\n\nexport const SlopeChartWrapper = styled.div`\n  height: 80vh;\n`;\n","// ADAPTED FROM @jaredreisinger/react-crossword\n\nimport React from \"react\";\n\n// To pass focus/highlight/etc., it's cleaner to use a context.\nexport const CrosswordContext = React.createContext({\n  focused: false,\n  selectedDirection: null,\n  selectedNumber: null,\n\n  // correct answers?\n});\n\nexport const CrosswordSizeContext = React.createContext({\n  cellSize: 0,\n  cellPadding: 0,\n  cellInner: 0,\n  cellHalf: 0,\n  fontSize: 0,\n});\n","// ADAPTED FROM @jaredreisinger/react-crossword\n\nimport React, { useCallback, useContext } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { ThemeContext } from \"styled-components\";\n\nimport { CrosswordSizeContext } from \"./context\";\n\n// expected props: row, col, answer, crossword, cellSize\n\n/**\n * An individual-letter answer cell within the crossword grid.\n *\n * A `Cell` lives inside the SVG for a [`Crossword`](#crossword), and renders at\n * a location determined by the `row`, `col`, and `cellSize` properties from\n * `cellData` and `renderContext`.\n */\nexport default function Cell({\n  cellData,\n  onClick,\n  focus,\n  highlight,\n  colorOverride,\n}) {\n  const { cellSize, cellPadding, cellInner, cellHalf, fontSize } = useContext(\n    CrosswordSizeContext\n  );\n  const {\n    // gridBackground,\n    cellBackground,\n    cellBorder,\n    textColor,\n    numberColor,\n    focusBackground,\n    highlightBackground,\n  } = useContext(ThemeContext);\n\n  const handleClick = useCallback(\n    (event) => {\n      event.preventDefault();\n      if (onClick) {\n        onClick(cellData);\n      }\n    },\n    [cellData, onClick]\n  );\n\n  const { row, col, guess, number } = cellData;\n\n  const x = col * cellSize;\n  const y = row * cellSize;\n\n  return (\n    <g\n      onClick={handleClick}\n      style={{ cursor: \"default\", fontSize: `${fontSize}px` }}\n    >\n      <rect\n        x={x + cellPadding}\n        y={y + cellPadding}\n        width={cellInner}\n        height={cellInner}\n        fill={\n          colorOverride\n            ? colorOverride\n            : focus\n            ? focusBackground\n            : highlight\n            ? highlightBackground\n            : cellBackground\n        }\n        stroke={cellBorder}\n        strokeWidth={cellSize / 50}\n      />\n      {number && (\n        <text\n          x={x + cellPadding * 4}\n          y={y + cellPadding * 4}\n          textAnchor=\"start\"\n          dominantBaseline=\"hanging\"\n          style={{ fontSize: \"50%\", fill: numberColor }}\n        >\n          {number}\n        </text>\n      )}\n      <text\n        x={x + cellHalf}\n        y={y + cellHalf + 1} // +1 for visual alignment?\n        textAnchor=\"middle\"\n        dominantBaseline=\"middle\"\n        style={{ fill: textColor }}\n      >\n        {guess}\n      </text>\n    </g>\n  );\n}\n\nCell.propTypes = {\n  /** the data specific to this cell */\n  cellData: PropTypes.shape({\n    row: PropTypes.number.isRequired,\n    col: PropTypes.number.isRequired,\n    guess: PropTypes.string.isRequired,\n    number: PropTypes.string,\n  }).isRequired,\n\n  /** whether this cell has focus */\n  focus: PropTypes.bool,\n\n  /** whether this cell is highlighted */\n  highlight: PropTypes.bool,\n\n  /** handler called when the cell is clicked */\n  onClick: PropTypes.func,\n\n  // color coding\n  colorOverride: PropTypes.string,\n};\n\nCell.defaultProps = {\n  focus: false,\n  highlight: false,\n  onClick: null,\n};\n\n// export default Cell;\n","// ADAPTED FROM @jaredreisinger/react-crossword\n\nimport React, { useCallback, useContext } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport styled, { ThemeContext } from \"styled-components\";\n\nimport { CrosswordContext } from \"./context\";\n\nconst ClueWrapper = styled.div.attrs((props) => ({\n  className: `clue${props.correct ? \" correct\" : \"\"}`,\n}))`\n  cursor: default;\n  background-color: ${(props) =>\n    props.highlight ? props.highlightBackground : \"transparent\"};\n`;\n\nexport default function Clue({\n  direction,\n  number,\n  children,\n  correct,\n  ...props\n}) {\n  const { highlightBackground } = useContext(ThemeContext);\n  const {\n    focused,\n    selectedDirection,\n    selectedNumber,\n    onClueSelected,\n  } = useContext(CrosswordContext);\n\n  const handleClick = useCallback(\n    (event) => {\n      event.preventDefault();\n      if (onClueSelected) {\n        onClueSelected(direction, number);\n      }\n    },\n    [direction, number, onClueSelected]\n  );\n\n  return (\n    <ClueWrapper\n      highlightBackground={highlightBackground}\n      highlight={\n        focused && direction === selectedDirection && number === selectedNumber\n      }\n      correct={correct}\n      {...props}\n      onClick={handleClick}\n      aria-label={`clue-${number}-${direction}`}\n    >\n      {number}: {children}\n    </ClueWrapper>\n  );\n}\n\nClue.propTypes = {\n  /** direction of the clue: \"across\" or \"down\"; passed back in onClick */\n  direction: PropTypes.string.isRequired,\n  /** number of the clue (the label shown); passed back in onClick */\n  number: PropTypes.string.isRequired,\n  /** clue text */\n  children: PropTypes.node,\n  /** whether the answer/guess is correct */\n  correct: PropTypes.bool,\n};\n\nClue.defaultProps = {\n  children: undefined,\n  correct: undefined,\n};\n","// ADAPTED FROM @jaredreisinger/react-crossword\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\n// import styled from 'styled-components';\n\nimport Clue from \"./Clue\";\n\nexport default function DirectionClues({ direction, clues }) {\n  return (\n    <div className=\"direction\">\n      {/* use something other than h3? */}\n      <h3 className=\"header\">{direction.toUpperCase()}</h3>\n      {clues.map(({ number, clue, correct }) => (\n        <Clue\n          key={number}\n          direction={direction}\n          number={number}\n          correct={correct}\n        >\n          {clue}\n        </Clue>\n      ))}\n    </div>\n  );\n}\n\nDirectionClues.propTypes = {\n  /** direction of this list of clues (\"across\" or \"down\") */\n  direction: PropTypes.string.isRequired,\n  /** clues for this List's direction */\n  clues: PropTypes.arrayOf(\n    PropTypes.shape({\n      /** number of the clue (the label shown) */\n      number: PropTypes.string.isRequired,\n      /** clue text */\n      clue: PropTypes.node.isRequired,\n      /** whether the answer/guess is correct */\n      correct: PropTypes.bool,\n    })\n  ).isRequired,\n};\n\nDirectionClues.defaultProps = {};\n","// ADAPTED FROM @jaredreisinger/react-crossword\n\nconst directionInfo = {\n  across: {\n    primary: \"col\",\n    orthogonal: \"row\",\n  },\n  down: {\n    primary: \"row\",\n    orthogonal: \"col\",\n  },\n};\n\nexport const bothDirections = Object.keys(directionInfo);\n\nexport function isAcross(direction) {\n  return direction === \"across\";\n}\n\nexport function otherDirection(direction) {\n  return isAcross(direction) ? \"down\" : \"across\";\n}\n\nexport function calculateExtents(data, direction) {\n  const dir = directionInfo[direction];\n  let primaryMax = 0;\n  let orthogonalMax = 0;\n\n  Object.entries(data[direction]).forEach(([i, info]) => {\n    const primary = info[dir.primary] + info.answer.length - 1;\n    if (primary > primaryMax) {\n      primaryMax = primary;\n    }\n\n    const orthogonal = info[dir.orthogonal];\n    if (orthogonal > orthogonalMax) {\n      orthogonalMax = orthogonal;\n    }\n  });\n\n  return {\n    [dir.primary]: primaryMax,\n    [dir.orthogonal]: orthogonalMax,\n  };\n}\n\nconst emptyCellData = {\n  used: false,\n  number: null,\n  answer: \"\",\n  guess: \"\",\n  locked: false,\n  // row: r,\n  // col: c,\n  across: null,\n  down: null,\n  color: null,\n};\n\nexport function createEmptyGrid(size) {\n  const gridData = Array(size);\n  // Rather than [x][y] in column-major order, the cells are indexed as\n  // [row][col] in row-major order.\n  for (let r = 0; r < size; r++) {\n    gridData[r] = Array(size);\n    for (let c = 0; c < size; c++) {\n      gridData[r][c] = {\n        ...emptyCellData,\n        row: r,\n        col: c,\n      };\n    }\n  }\n\n  return gridData;\n}\n\nexport function fillClues(gridData, clues, data, direction) {\n  const dir = directionInfo[direction];\n\n  Object.entries(data[direction]).forEach(([number, info]) => {\n    const { row: rowStart, col: colStart, clue, answer, color } = info;\n    for (let i = 0; i < answer.length; i++) {\n      const row = rowStart + (dir.primary === \"row\" ? i : 0);\n      const col = colStart + (dir.primary === \"col\" ? i : 0);\n      const cellData = gridData[row][col];\n\n      // TODO?: check to ensure the answer is the same if it's already set?\n      cellData.used = true;\n      cellData.answer = answer[i];\n      cellData[direction] = number;\n      cellData.color = color;\n\n      if (i === 0) {\n        // TODO?: check to ensure the number is the same if it's already set?\n        cellData.number = number;\n      }\n    }\n\n    clues[direction].push({ number, clue });\n  });\n\n  clues[direction].sort(byNumber);\n}\n\n// Given the \"nice format\" for a crossword, generate the usable data optimized\n// for rendering and our interactivity.\nexport function createGridData(data) {\n  const acrossMax = calculateExtents(data, \"across\");\n  const downMax = calculateExtents(data, \"down\");\n\n  const size =\n    Math.max(...Object.values(acrossMax), ...Object.values(downMax)) + 1;\n\n  const gridData = createEmptyGrid(size);\n\n  // Now fill with answers... and also collect the clues\n  const clues = {\n    across: [],\n    down: [],\n  };\n\n  fillClues(gridData, clues, data, \"across\");\n  fillClues(gridData, clues, data, \"down\");\n\n  return { size, gridData, clues };\n}\n\n// sort helper for clues...\nexport function byNumber(a, b) {\n  const aNum = Number.parseInt(a.number, 10);\n  const bNum = Number.parseInt(b.number, 10);\n\n  return aNum - bNum;\n}\n\nexport function clearGuesses(storageKey) {\n  if (!window.localStorage) {\n    return;\n  }\n\n  window.localStorage.removeItem(storageKey);\n}\n\nexport function saveGuesses(gridData, storageKey) {\n  const { localStorage } = window;\n  if (!localStorage) {\n    return;\n  }\n\n  const guesses = serializeGuesses(gridData);\n\n  const saveData = {\n    date: Date.now(),\n    guesses,\n  };\n\n  localStorage.setItem(storageKey, JSON.stringify(saveData));\n}\n\nexport function serializeGuesses(gridData) {\n  const guesses = gridData.reduce((memo, row, r) => {\n    return row.reduce((memoInner, cellData, c) => {\n      const { guess } = cellData;\n      if (guess !== \"\") {\n        memoInner[`${r}_${c}`] = cellData.guess;\n      }\n      return memoInner;\n    }, memo);\n  }, {});\n\n  return guesses;\n}\n\nexport function loadGuesses(gridData, storageKey) {\n  const { localStorage } = window;\n  if (!localStorage) {\n    return;\n  }\n\n  const saveRaw = localStorage.getItem(storageKey);\n  if (!saveRaw) {\n    return;\n  }\n\n  const saveData = JSON.parse(saveRaw);\n\n  // TODO: check date for expiration?\n  deserializeGuesses(gridData, saveData.guesses);\n}\n\nexport function deserializeGuesses(gridData, guesses) {\n  Object.entries(guesses).forEach(([key, val]) => {\n    const [r, c] = key.split(\"_\");\n    // ignore any out-of-bounds guesses!\n    if (r <= gridData.length - 1 && c <= gridData[0].length - 1) {\n      gridData[r][c].guess = val;\n    }\n  });\n}\n\nexport function findCorrectAnswers(data, gridData) {\n  const correctAnswers = [];\n\n  bothDirections.forEach((direction) => {\n    const across = isAcross(direction);\n    Object.entries(data[direction]).forEach(([num, info]) => {\n      const { row, col } = info;\n      let correct = true;\n      for (let i = 0; i < info.answer.length; i++) {\n        const r = across ? row : row + i;\n        const c = across ? col + i : col;\n        if (gridData[r][c].guess !== info.answer[i]) {\n          correct = false;\n          break;\n        }\n      }\n      if (correct) {\n        // same args as notifyCorrect: direction, number, answer\n        correctAnswers.push([direction, num, info.answer]);\n      }\n    });\n  });\n\n  return correctAnswers;\n}\n","// ADAPTED FROM @jaredreisinger/react-crossword\n\nimport React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport produce from \"immer\";\nimport styled, { ThemeContext, ThemeProvider } from \"styled-components\";\n\nimport Cell from \"./Cell\";\nimport DirectionClues from \"./DirectionClues\";\n\nimport {\n  bothDirections,\n  createGridData,\n  isAcross,\n  otherDirection,\n  clearGuesses,\n  saveGuesses,\n  loadGuesses,\n  findCorrectAnswers,\n} from \"./util\";\n\nimport { CrosswordContext, CrosswordSizeContext } from \"./context\";\n\n// TODO: make this a component property!\nconst defaultStorageKey = \"guesses\";\n\nconst defaultTheme = {\n  columnBreakpoint: \"768px\",\n  gridBackground: \"rgb(0,0,0)\",\n  cellBackground: \"rgb(255,255,255)\",\n  cellBorder: \"rgb(0,0,0)\",\n  textColor: \"rgb(0,0,0)\",\n  numberColor: \"rgba(0,0,0, 0.25)\",\n  focusBackground: \"rgb(255,255,0)\",\n  highlightBackground: \"rgb(255,255,204)\",\n};\n\n// eslint-disable-next-line\nconst OuterWrapper = styled.div.attrs((props) => ({\n  className: `crossword${props.correct ? \" correct\" : \"\"}`,\n}))`\n  margin: 0;\n  padding: 0;\n  border: 0;\n  /* position: relative; */\n  /* width: 40%; */\n  display: flex;\n  flex-direction: row;\n\n  @media (max-width: ${(props) => props.theme.columnBreakpoint}) {\n    flex-direction: column;\n  }\n`;\n\nconst GridWrapper = styled.div.attrs((props) => ({\n  className: \"grid\",\n}))`\n  /* position: relative; */\n  min-width: 20rem;\n  max-width: 60rem; /* Should the size matter? */\n  width: auto;\n  flex: 2 1 50%;\n`;\n\nconst CluesWrapper = styled.div.attrs((props) => ({\n  className: \"clues\",\n}))`\n  padding: 0 1em;\n  flex: 1 2 25%;\n\n  @media (max-width: ${(props) => props.theme.columnBreakpoint}) {\n    margin-top: 2em;\n  }\n\n  .direction {\n    margin-bottom: 2em;\n    /* padding: 0 1em;\n    flex: 1 1 20%; */\n\n    .header {\n      margin-top: 0;\n      margin-bottom: 0.5em;\n    }\n\n    div {\n      margin-top: 0.5em;\n    }\n  }\n`;\n\n/**\n * The primary, and default, export from the react-crossword library, Crossword\n * renders an answer grid and clues, and manages data and user interaction.\n */\nconst Crossword = React.forwardRef(\n  (\n    {\n      data,\n      onCorrect,\n      onLoadedCorrect,\n      onCrosswordCorrect,\n      onCellChange,\n      useStorage,\n      theme,\n      colorCode,\n    },\n    ref\n  ) => {\n    const [size, setSize] = useState(null);\n    const [gridData, setGridData] = useState(null);\n    const [clues, setClues] = useState(null);\n    const [focused, setFocused] = useState(false);\n    const [focusedRow, setFocusedRow] = useState(0);\n    const [focusedCol, setFocusedCol] = useState(0);\n    const [currentDirection, setCurrentDirection] = useState(\"across\");\n    const [currentNumber, setCurrentNumber] = useState(\"1\");\n    const [bulkChange, setBulkChange] = useState(null);\n    const [checkQueue, setCheckQueue] = useState([]);\n    const [crosswordCorrect, setCrosswordCorrect] = useState(false);\n\n    const inputRef = useRef();\n\n    const contextTheme = useContext(ThemeContext);\n\n    const getCellData = useCallback(\n      (row, col) => {\n        if (row >= 0 && row < size && col >= 0 && col < size) {\n          return gridData[row][col];\n        }\n\n        // fake cellData to represent \"out of bounds\"\n        return { row, col, used: false, outOfBounds: true };\n      },\n      [size, gridData]\n    );\n\n    const setCellCharacter = useCallback(\n      (row, col, char) => {\n        const cell = getCellData(row, col);\n\n        if (!cell.used) {\n          return;\n        }\n\n        // If the character is already the cell's guess, there's nothing to do.\n        if (cell.guess === char) {\n          return;\n        }\n\n        // update the gridData with the guess\n        setGridData(\n          produce((draft) => {\n            draft[row][col].guess = char;\n          })\n        );\n\n        // push the row/col for checking!\n        setCheckQueue(\n          produce((draft) => {\n            draft.push({ row, col });\n          })\n        );\n\n        if (onCellChange) {\n          onCellChange(row, col, char);\n        }\n      },\n      [getCellData, onCellChange]\n    );\n\n    const notifyCorrect = useCallback(\n      (direction, number, answer) => {\n        if (onCorrect) {\n          // We *used* to need a timeout workaround to ensure this happened\n          // *after* the state had updated and the DOM rendered.... do we still?\n          //nCorrect(direction, number, answer);\n\n          // For future reference, the call looked like:\n          //\n          setTimeout(() => {\n            window.requestAnimationFrame(() => {\n              onCorrect(direction, number, answer);\n            });\n          });\n        }\n      },\n      [onCorrect]\n    );\n\n    const checkCorrectness = useCallback(\n      (row, col) => {\n        const cell = getCellData(row, col);\n\n        // check all the cells for both across and down answers that use this\n        // cell\n        bothDirections.forEach((direction) => {\n          const across = isAcross(direction);\n          const number = cell[direction];\n          if (!number) {\n            return;\n          }\n\n          const info = data[direction][number];\n\n          // We start by looking at the current cell... if it's not correct, we\n          // don't need to check anything else!\n          let correct = cell.guess === cell.answer;\n\n          if (correct) {\n            // We *could* compare cell.guess against cell.answer for all the\n            // cells, but info.answer is a simple string and gets us the length\n            // as well (and we only have to calulate row/col math once).\n            for (let i = 0; i < info.answer.length; i++) {\n              const checkCell = getCellData(\n                info.row + (across ? 0 : i),\n                info.col + (across ? i : 0)\n              );\n\n              if (checkCell.guess !== info.answer[i]) {\n                correct = false;\n                break;\n              }\n            }\n          }\n\n          // update the clue state\n          setClues(\n            produce((draft) => {\n              const clueInfo = draft[direction].find(\n                (i) => i.number === number\n              );\n              clueInfo.correct = correct;\n            })\n          );\n\n          if (correct) {\n            notifyCorrect(direction, number, info.answer);\n          }\n        });\n      },\n      [getCellData]\n    );\n\n    // Any time the checkQueue changes, call checkCorrectness!\n    useEffect(() => {\n      if (checkQueue.length === 0) {\n        return;\n      }\n\n      checkQueue.forEach(({ row, col }) => checkCorrectness(row, col));\n      setCheckQueue([]);\n    }, [checkQueue, checkCorrectness]);\n\n    // Any time the clues change, determine if they are all correct or not.\n    useEffect(() => {\n      setCrosswordCorrect(\n        clues &&\n          bothDirections.every((direction) =>\n            clues[direction].every((clueInfo) => clueInfo.correct)\n          )\n      );\n    }, [clues]);\n\n    // Let the consumer know everything's correct (or not) if they've asked to\n    // be informed.\n    useEffect(() => {\n      if (onCrosswordCorrect) {\n        onCrosswordCorrect(crosswordCorrect);\n      }\n    }, [crosswordCorrect, onCrosswordCorrect]);\n\n    // focus and movement\n    const focus = useCallback(() => {\n      if (inputRef.current) {\n        inputRef.current.focus();\n        setFocused(true);\n      }\n    }, []);\n\n    const moveTo = useCallback(\n      (row, col, directionOverride) => {\n        let direction = directionOverride ?? currentDirection;\n        const candidate = getCellData(row, col);\n\n        if (!candidate.used) {\n          return false;\n        }\n\n        if (!candidate[direction]) {\n          direction = otherDirection(direction);\n        }\n\n        setFocusedRow(row);\n        setFocusedCol(col);\n        setCurrentDirection(direction);\n        setCurrentNumber(candidate[direction]);\n\n        return candidate;\n      },\n      [getCellData]\n    );\n\n    const moveRelative = useCallback(\n      (dRow, dCol) => {\n        // We expect *only* one of dRow or dCol to have a non-zero value, and\n        // that's the direction we will \"prefer\".  If *both* are set (or zero),\n        // we don't change the direction.\n        let direction;\n        if (dRow !== 0 && dCol === 0) {\n          direction = \"down\";\n        } else if (dRow === 0 && dCol !== 0) {\n          direction = \"across\";\n        }\n\n        const cell = moveTo(focusedRow + dRow, focusedCol + dCol, direction);\n\n        return cell;\n      },\n      [focusedRow, focusedCol, moveTo]\n    );\n\n    const moveForward = useCallback(() => {\n      const across = isAcross(currentDirection);\n      moveRelative(across ? 0 : 1, across ? 1 : 0);\n    }, [currentDirection, moveRelative]);\n\n    const moveBackward = useCallback(() => {\n      const across = isAcross(currentDirection);\n      moveRelative(across ? 0 : -1, across ? -1 : 0);\n    }, [currentDirection, moveRelative]);\n\n    // keyboard handling\n    const handleSingleCharacter = useCallback(\n      (char) => {\n        setCellCharacter(focusedRow, focusedCol, char.toUpperCase());\n        moveForward();\n      },\n      [focusedRow, focusedCol, setCellCharacter, moveForward]\n    );\n\n    // We use the keydown event for control/arrow keys, but not for textual\n    // input, because it's hard to suss out when a key is \"regular\" or not.\n    const handleInputKeyDown = useCallback(\n      (event) => {\n        // if ctrl, alt, or meta are down, ignore the event (let it bubble)\n        if (event.ctrlKey || event.altKey || event.metaKey) {\n          return;\n        }\n\n        let preventDefault = true;\n        const { key } = event;\n        // console.log('CROSSWORD KEYDOWN', event.key);\n\n        // FUTURE: should we \"jump\" over black space?  That might help some for\n        // keyboard users.\n        switch (key) {\n          case \"ArrowUp\":\n            moveRelative(-1, 0);\n            break;\n\n          case \"ArrowDown\":\n            moveRelative(1, 0);\n            break;\n\n          case \"ArrowLeft\":\n            moveRelative(0, -1);\n            break;\n\n          case \"ArrowRight\":\n            moveRelative(0, 1);\n            break;\n\n          case \" \": // treat space like tab?\n          case \"Tab\": {\n            const other = otherDirection(currentDirection);\n            const cellData = getCellData(focusedRow, focusedCol);\n            if (cellData[other]) {\n              setCurrentDirection(other);\n              setCurrentNumber(cellData[other]);\n            }\n            break;\n          }\n\n          // Backspace: delete the current cell, and move to the previous cell\n          // Delete:    delete the current cell, but don't move\n          case \"Backspace\":\n          case \"Delete\": {\n            setCellCharacter(focusedRow, focusedCol, \"\");\n            if (key === \"Backspace\") {\n              moveBackward();\n            }\n            break;\n          }\n\n          case \"Home\":\n          case \"End\": {\n            // move to beginning/end of this entry?\n            const info = data[currentDirection][currentNumber];\n            const {\n              answer: { length },\n            } = info;\n            let { row, col } = info;\n            if (key === \"End\") {\n              const across = isAcross(currentDirection);\n              if (across) {\n                col += length - 1;\n              } else {\n                row += length - 1;\n              }\n            }\n\n            moveTo(row, col);\n            break;\n          }\n\n          default:\n            // It would be nice to handle \"regular\" characters with onInput, but\n            // that is still experimental, so we can't count on it.  Instead, we\n            // assume that only \"length 1\" values are regular.\n            if (key.length !== 1) {\n              preventDefault = false;\n              break;\n            }\n\n            handleSingleCharacter(key);\n            break;\n        }\n\n        if (preventDefault) {\n          event.preventDefault();\n        }\n      },\n      [\n        data,\n        focusedRow,\n        focusedCol,\n        currentDirection,\n        currentNumber,\n        getCellData,\n        setCellCharacter,\n        moveRelative,\n      ]\n    );\n\n    const handleInputChange = useCallback((event) => {\n      event.preventDefault();\n      setBulkChange(event.target.value);\n    }, []);\n\n    useEffect(() => {\n      if (!bulkChange) {\n        return;\n      }\n\n      // handle bulkChange by updating a character at a time (this lets us\n      // leverage the existing character-entry logic).\n      handleSingleCharacter(bulkChange[0]);\n      setBulkChange(bulkChange.length === 1 ? null : bulkChange.substring(1));\n    }, [bulkChange, handleSingleCharacter]);\n\n    // When the data changes, recalculate the gridData, size, etc.\n    useEffect(() => {\n      // eslint-disable-next-line no-shadow\n      const { size, gridData, clues } = createGridData(data);\n\n      let loadedCorrect;\n      if (useStorage) {\n        loadGuesses(gridData, defaultStorageKey);\n        loadedCorrect = findCorrectAnswers(data, gridData);\n\n        loadedCorrect.forEach(([direction, num]) => {\n          const clueInfo = clues[direction].find((i) => i.number === num);\n          clueInfo.correct = true;\n        });\n      }\n\n      setSize(size);\n      setGridData(gridData);\n      setClues(clues);\n\n      // Should we start with 1-across highlighted/focused?\n\n      // TODO: track input-field focus so we don't draw highlight when we're not\n      // really focused, *and* use first actual clue (whether across or down?)\n      setFocusedRow(0);\n      setFocusedCol(0);\n      setCurrentDirection(\"across\");\n      setCurrentNumber(\"1\");\n\n      setBulkChange(null);\n\n      // trigger any \"loaded correct\" guesses...\n      if (loadedCorrect && loadedCorrect.length > 0 && onLoadedCorrect) {\n        onLoadedCorrect(loadedCorrect);\n      }\n    }, [data, onLoadedCorrect, useStorage]);\n\n    useEffect(() => {\n      if (gridData === null || !useStorage) {\n        return;\n      }\n\n      saveGuesses(gridData, defaultStorageKey);\n    }, [gridData, useStorage]);\n\n    const handleCellClick = useCallback(\n      (cellData) => {\n        const { row, col } = cellData;\n        const other = otherDirection(currentDirection);\n\n        // should this use moveTo?\n        setFocusedRow(row);\n        setFocusedCol(col);\n\n        let direction = currentDirection;\n\n        // We switch to the \"other\" direction if (a) the current direction isn't\n        // available in the clicked cell, or (b) we're already focused and the\n        // clicked cell is the focused cell, *and* the other direction is\n        // available.\n        if (\n          !cellData[currentDirection] ||\n          (focused &&\n            row === focusedRow &&\n            col === focusedCol &&\n            cellData[other])\n        ) {\n          setCurrentDirection(other);\n          direction = other;\n        }\n\n        setCurrentNumber(cellData[direction]);\n\n        focus();\n      },\n      [focused, focusedRow, focusedCol, currentDirection, focus]\n    );\n\n    const handleInputClick = useCallback(\n      (event) => {\n        // *don't* event.preventDefault(), because we want the input to actually\n        // take focus\n\n        // Like general cell-clicks, cliking on the input can change direction.\n        // Unlike cell clicks, we *know* we're clicking on the already-focused\n        // cell!\n        const other = otherDirection(currentDirection);\n        const cellData = getCellData(focusedRow, focusedCol);\n\n        let direction = currentDirection;\n\n        if (focused && cellData[other]) {\n          setCurrentDirection(other);\n          direction = other;\n        }\n\n        setCurrentNumber(cellData[direction]);\n        focus();\n      },\n      [currentDirection, focusedRow, focusedCol, getCellData, focus]\n    );\n\n    const handleClueSelected = useCallback(\n      (direction, number) => {\n        const info = data[direction][number];\n        // TODO: sanity-check info?\n        moveTo(info.row, info.col, direction);\n        focus();\n      },\n      [data, moveTo, focus]\n    );\n\n    // expose some imperative methods\n    useImperativeHandle(\n      ref,\n      () => ({\n        /**\n         * Sets focus to the crossword component.\n         */\n        focus: () => {\n          focus();\n        },\n\n        /**\n         * Resets the entire crossword; clearing all answers in the grid and\n         * also any persisted data.\n         */\n        reset: () => {\n          setGridData(\n            produce((draft) => {\n              draft.forEach((rowData) => {\n                rowData.forEach((cellData) => {\n                  if (cellData.used) {\n                    cellData.guess = \"\";\n                  }\n                });\n              });\n            })\n          );\n\n          setClues(\n            produce((draft) => {\n              bothDirections.forEach((direction) => {\n                draft[direction].forEach((clueInfo) => {\n                  delete clueInfo.correct;\n                });\n              });\n            })\n          );\n\n          if (useStorage) {\n            clearGuesses(defaultStorageKey);\n          }\n        },\n\n        /**\n         * Fills all the answers in the grid and calls the `onLoadedCorrect`\n         * callback with _**every**_ answer.\n         */\n        fillAllAnswers: () => {\n          setGridData(\n            produce((draft) => {\n              draft.forEach((rowData) => {\n                rowData.forEach((cellData) => {\n                  if (cellData.used) {\n                    cellData.guess = cellData.answer;\n                  }\n                });\n              });\n            })\n          );\n\n          setClues(\n            produce((draft) => {\n              bothDirections.forEach((direction) => {\n                draft[direction].forEach((clueInfo) => {\n                  clueInfo.correct = true;\n                });\n              });\n            })\n          );\n\n          // trigger onLoadedCorrect with every clue!\n          if (onLoadedCorrect) {\n            const loadedCorrect = [];\n            bothDirections.forEach((direction) => {\n              Object.entries(data[direction]).forEach(([number, info]) => {\n                loadedCorrect.push([direction, number, info.answer]);\n              });\n            });\n\n            onLoadedCorrect(loadedCorrect);\n          }\n        },\n\n        /**\n         * Returns whether the crossword is entirely correct or not.\n         *\n         * @since 2.2.0\n         */\n        isCrosswordCorrect: () => {\n          return crosswordCorrect;\n        },\n      }),\n      [data, onLoadedCorrect, useStorage, focus, crosswordCorrect]\n    );\n\n    // constants for rendering...\n\n    // We have several properties that we bundle together as context for the\n    // cells, rather than have them as independent properties.  (Or should they\n    // stay separate? Or be passed as \"spread\" values?)\n    const cellSize = 100 / size;\n    const cellPadding = 0.125;\n    const cellInner = cellSize - cellPadding * 2;\n    const cellHalf = cellSize / 2;\n    const fontSize = cellInner * 0.7;\n\n    const context = {\n      focused,\n      selectedDirection: currentDirection,\n      selectedNumber: currentNumber,\n      onClueSelected: handleClueSelected,\n    };\n\n    // The final theme is the merger of three values: the \"theme\" property\n    // passed to the component (which takes precedence), any values from\n    // ThemeContext, and finally the \"defaultTheme\" values fill in for any\n    // needed ones that are missing.  (We create this in standard last-one-wins\n    // order in Javascript, of course.)\n    const finalTheme = { ...defaultTheme, ...contextTheme, ...theme };\n\n    // REVIEW: do we want to recalc this all the time, or cache in state?\n    const cells = [];\n    if (gridData) {\n      gridData.forEach((rowData, row) => {\n        rowData.forEach((cellData, col) => {\n          if (!cellData.used) {\n            return;\n          }\n          cells.push(\n            <Cell\n              // eslint-disable-next-line react/no-array-index-key\n              key={`R${row}C${col}`}\n              cellData={cellData}\n              focus={focused && row === focusedRow && col === focusedCol}\n              highlight={\n                focused &&\n                currentNumber &&\n                cellData[currentDirection] === currentNumber\n              }\n              onClick={handleCellClick}\n              colorOverride={colorCode ? cellData.color : null}\n            />\n          );\n        });\n      });\n    }\n\n    return (\n      <CrosswordContext.Provider value={context}>\n        <CrosswordSizeContext.Provider\n          value={{ cellSize, cellPadding, cellInner, cellHalf, fontSize }}\n        >\n          <ThemeProvider theme={finalTheme}>\n            <OuterWrapper correct={crosswordCorrect}>\n              <GridWrapper>\n                {/*\n                This div is hard-coded because we *need* a zero-padded,\n                relative-positioned element for aligning the <input> with the\n                cells in the <svg>.\n              */}\n                <div style={{ margin: 0, padding: 0, position: \"relative\" }}>\n                  <svg viewBox=\"0 0 100 100\">\n                    <rect\n                      x={0}\n                      y={0}\n                      width={100}\n                      height={100}\n                      fill={finalTheme.gridBackground}\n                    />\n                    {cells}\n                  </svg>\n                  <input\n                    ref={inputRef}\n                    aria-label=\"crossword-input\"\n                    type=\"text\"\n                    onClick={handleInputClick}\n                    onKeyDown={handleInputKeyDown}\n                    onChange={handleInputChange}\n                    value=\"\"\n                    // onInput={this.handleInput}\n                    autoComplete=\"off\"\n                    spellCheck=\"false\"\n                    autoCorrect=\"off\"\n                    style={{\n                      position: \"absolute\",\n                      // In order to ensure the top/left positioning makes sense,\n                      // there is an absolutely-positioned <div> with no\n                      // margin/padding that we *don't* expose to consumers.  This\n                      // keeps the math much more reliable.  (But we're still\n                      // seeing a slight vertical deviation towards the bottom of\n                      // the grid!  The \"* 0.995\" seems to help.)\n                      top: `calc(${focusedRow * cellSize * 0.995}% + 2px)`,\n                      left: `calc(${focusedCol * cellSize}% + 2px)`,\n                      width: `calc(${cellSize}% - 4px)`,\n                      height: `calc(${cellSize}% - 4px)`,\n                      fontSize: `${fontSize * 6}px`, // waaay too small...?\n                      textAlign: \"center\",\n                      textAnchor: \"middle\",\n                      backgroundColor: \"transparent\",\n                      caretColor: \"transparent\",\n                      margin: 0,\n                      padding: 0,\n                      border: 0,\n                      cursor: \"default\",\n                    }}\n                  />\n                </div>\n              </GridWrapper>\n              <CluesWrapper>\n                {clues &&\n                  bothDirections.map((direction) => (\n                    <DirectionClues\n                      key={direction}\n                      direction={direction}\n                      clues={clues[direction]}\n                    />\n                  ))}\n              </CluesWrapper>\n            </OuterWrapper>\n          </ThemeProvider>\n        </CrosswordSizeContext.Provider>\n      </CrosswordContext.Provider>\n    );\n  }\n);\n\nCrossword.displayName = \"Crossword\";\n\nconst clueShape = PropTypes.shape({\n  clue: PropTypes.string.isRequired,\n  answer: PropTypes.string.isRequired,\n  row: PropTypes.number.isRequired,\n  col: PropTypes.number.isRequired,\n});\n\nCrossword.propTypes = {\n  /** clue/answer data; see <a href=\"#cluedata-format\">Clue/data format</a> for details. */\n  data: PropTypes.shape({\n    /** \"across\" clues and answers */\n    across: PropTypes.objectOf(clueShape),\n    /** \"down\" clues and answers */\n    down: PropTypes.objectOf(clueShape),\n  }).isRequired,\n\n  /** presentation values for the crossword; these override any values coming from a parent ThemeProvider context. */\n  theme: PropTypes.shape({\n    /** browser-width at which the clues go from showing beneath the grid to showing beside the grid */\n    columnBreakpoint: PropTypes.string,\n\n    /** overall background color (fill) for the crossword grid; can be `'transparent'` to show through a page background image */\n    gridBackground: PropTypes.string,\n    /**  background for an answer cell */\n    cellBackground: PropTypes.string,\n    /** border for an answer cell */\n    cellBorder: PropTypes.string,\n    /** color for answer text (entered by the player) */\n    textColor: PropTypes.string,\n    /** color for the across/down numbers in the grid */\n    numberColor: PropTypes.string,\n    /** background color for the cell with focus, the one that the player is typing into */\n    focusBackground: PropTypes.string,\n    /** background color for the cells in the answer the player is working on,\n     * helps indicate in which direction focus will be moving; also used as a\n     * background on the active clue  */\n    highlightBackground: PropTypes.string,\n  }),\n\n  /** whether to use browser storage to persist the player's work-in-progress */\n  useStorage: PropTypes.bool,\n\n  /** callback function that fires when a player answers a clue correctly; called with `(direction, number, answer)` arguments, where `direction` is `'across'` or `'down'`, `number` is the clue number as text (like `'1'`), and `answer` is the answer itself */\n  onCorrect: PropTypes.func,\n  /** callback function that's called when a crossword is loaded, to batch up correct answers loaded from storage; passed an array of the same values that `onCorrect` would recieve */\n  onLoadedCorrect: PropTypes.func,\n  /** callback function that's called when the overall crossword is completely correct (or not) */\n  onCrosswordCorrect: PropTypes.func,\n\n  /**\n   *  callback function called when a cell changes (e.g. when the user types a\n   *  letter); called with `(row, col, char)` arguments, where the `row` and\n   *  `column` are the 0-based position of the cell, and `char` is the character\n   *  typed (already massaged into upper-case)\n   *\n   *  @since 2.1.0\n   */\n  onCellChange: PropTypes.func,\n\n  colorCode: PropTypes.bool,\n};\n\nCrossword.defaultProps = {\n  theme: null,\n  useStorage: true,\n  // useStorage: false,\n  onCorrect: null,\n  onLoadedCorrect: null,\n  onCrosswordCorrect: null,\n  onCellChange: null,\n  colorCode: false,\n};\n\nexport default Crossword;\n","import React, { useRef, useEffect } from \"react\";\nimport Crossword from \"./Crossword.js\";\nimport confetti from \"canvas-confetti\";\n\nconst CrosswordChart = ({ data, colorCode, showAnswers }) => {\n  const crosswordRef = useRef(null);\n\n  // start puzzle blank\n  useEffect(() => {\n    crosswordRef.current.reset();\n  }, []);\n\n  // fill in answers if asked to\n  useEffect(() => {\n    if (showAnswers) {\n      crosswordRef.current.fillAllAnswers();\n    }\n  }, [showAnswers]);\n\n  return (\n    <div>\n      <Crossword\n        ref={crosswordRef}\n        theme={{\n          numberColor: \"black\",\n          focusBackground: \"gold\",\n          highlightBackground: \"#72cefc\",\n        }}\n        data={data}\n        onCorrect={() => {\n          if (crosswordRef.current.isCrosswordCorrect()) {\n            confetti();\n          }\n        }}\n        colorCode={colorCode ? true : false}\n      />\n      {!showAnswers && (\n        <>\n          <button onClick={() => crosswordRef.current.fillAllAnswers()}>\n            skip to results\n          </button>\n          <button\n            onClick={() => {\n              crosswordRef.current.reset();\n            }}\n          >\n            clear\n          </button>\n        </>\n      )}\n    </div>\n  );\n};\n\nexport default CrosswordChart;\n","export const COLORS = {\n  white: \"#F2D0A4\",\n  poc: \"#DB7C26\",\n  man: \"#CBC5EA\",\n  woman: \"#8A7090\",\n  nonbinary: \"#8D3B72\",\n};\n","import _ from \"lodash\";\nimport { COLORS } from \"../styles/colors.js\";\n\n// workaround for react so links work\nexport const createMarkup = (content) => {\n  return { __html: content };\n};\n\n// rounds an array of percentages so that they add up to 100, minimizing error\nexport const roundData = (arr, target = 100) => {\n  const off =\n    target -\n    _.reduce(\n      arr,\n      function (acc, x) {\n        return acc + Math.round(x);\n      },\n      0\n    );\n  return _.chain(arr)\n    .sortBy(function (x) {\n      return Math.round(x) - x;\n    })\n    .map(function (x, i) {\n      return Math.round(x) + (off > i) - (i >= arr.length + off);\n    })\n    .value();\n};\n\n// adds a field 'color' to crossword data based on the metric (gender or race) that's being displayed\nexport const addColorsToData = (data, metric) => {\n  const updatedData = { across: {}, down: {} };\n  const acrossKeys = _.keys(data.across);\n  const downKeys = _.keys(data.down);\n  _.forEach(acrossKeys, (number) => {\n    updatedData.across[number] = {\n      ...data.across[number],\n      color: COLORS[data.across[number][metric]],\n    };\n  });\n  _.forEach(downKeys, (number) => {\n    updatedData.down[number] = {\n      ...data.down[number],\n      color: COLORS[data.down[number][metric]],\n    };\n  });\n  return updatedData;\n};\n","import React, { useState, useEffect } from \"react\";\nimport {\n  WaffleChartWrapper,\n  WaffleChartBounds,\n  WaffleChartLabel,\n  Block,\n  Percentage,\n} from \"../../styles/styles.js\";\nimport _ from \"lodash\";\nimport { roundData } from \"../utils.js\";\n\nconst WaffleChart = ({ title, data, colors, changeMetric }) => {\n  const [colorLookup, setColorLookup] = useState(null);\n  const [roundedData, setRoundedData] = useState(null);\n\n  // round data to whole numbers\n  useEffect(() => {\n    setRoundedData(roundData(data));\n  }, [data]);\n\n  // when we get colors, create a color map from i (0-99) -> color of square\n  useEffect(() => {\n    const colorOptions = colors\n      ? colors\n      : roundedData.map(\n          (d) => \"#\" + Math.floor(Math.random() * 16777215).toString(16)\n        );\n\n    const updatedColorLookup = {};\n    let countTo100 = 0;\n    _.forEach(roundedData, (groupPercent, groupNum) => {\n      _.forEach(_.range(0, groupPercent), (i) => {\n        updatedColorLookup[countTo100] = colorOptions[groupNum];\n        countTo100 += 1;\n      });\n    });\n\n    setColorLookup(updatedColorLookup);\n  }, [colors]);\n\n  return (\n    colorLookup &&\n    roundedData && (\n      <WaffleChartWrapper>\n        <div>\n          <div style={{ marginBottom: \"5px\" }}>{title}</div>\n          <WaffleChartBounds onClick={changeMetric}>\n            {_.range(0, 100).map((i) => (\n              <Block key={i} color={colorLookup[i]} />\n            ))}\n          </WaffleChartBounds>\n        </div>\n        <div style={{ marginLeft: \"10px\", marginTop: \"18px\" }}>\n          <WaffleChartLabel color={colors[0]}>\n            <Percentage>{roundedData[0]}%</Percentage>\n            {title.toLowerCase() === \"gender\" ? \"women\" : \"POC\"}\n          </WaffleChartLabel>\n          <WaffleChartLabel color={colors[1]}>\n            <Percentage>{roundedData[1]}%</Percentage>\n            {title.toLowerCase() === \"gender\" ? \"men\" : \"white\"}\n          </WaffleChartLabel>\n        </div>\n      </WaffleChartWrapper>\n    )\n  );\n};\n\nexport default WaffleChart;\n","import React, { useState } from \"react\";\nimport copy from \"../../data/copy.json\";\nimport {\n  StoryTitle,\n  ScrollyStep,\n  CrosswordWaffleWrapper,\n} from \"../../styles/styles.js\";\nimport _ from \"lodash\";\nimport CrosswordChart from \"../charts/crossword/CrosswordChart.jsx\";\nimport WaffleChart from \"../charts/WaffleChart.jsx\";\nimport raceGenderBreakdown from \"../../data/raceGenderBreakdownByDecade.json\";\nimport { Scrollama, Step } from \"react-scrollama\";\nimport { addColorsToData, createMarkup } from \"../utils.js\";\nimport { COLORS } from \"../../styles/colors.js\";\n\nconst tempData = {\n  across: {\n    1: {\n      clue: \"McGhee\",\n      answer: \"MICHELLE\",\n      row: 4,\n      col: 0,\n      race: \"poc\",\n      gender: \"woman\",\n    },\n    2: {\n      clue: \"The proof is in the __\",\n      answer: \"PUDDING\",\n      row: 1,\n      col: 3,\n      race: \"white\",\n      gender: \"man\",\n    },\n  },\n  down: {\n    3: {\n      clue: \"Goldenberg\",\n      answer: \"RUSSELL\",\n      row: 0,\n      col: 4,\n      race: \"white\",\n      gender: \"man\",\n    },\n    4: {\n      clue: \"Jan\",\n      answer: \"DIEHM\",\n      row: 3,\n      col: 1,\n      race: \"white\",\n      gender: \"woman\",\n    },\n  },\n};\n\nconst IntroPuzzle = () => {\n  const [stepIndex, setStepIndex] = useState(null);\n  const [metric, setMetric] = useState(\"gender\");\n\n  // advancing scrollytelling steps\n  const onStepEnter = ({ data }) => {\n    setStepIndex(data);\n  };\n\n  return (\n    <div\n      style={{ display: \"flex\", flexDirection: \"column\", alignItems: \"center\" }}\n    >\n      <StoryTitle>{copy.title}</StoryTitle>\n      <div>By Michelle McGhee and Russell Goldenberg</div>\n\n      <CrosswordWaffleWrapper>\n        <CrosswordChart\n          data={addColorsToData(tempData, metric)}\n          colorCode={stepIndex === 1}\n          showAnswers={stepIndex === 1}\n        />\n        <div style={{ opacity: stepIndex === 1 ? 1 : 0 }}>\n          <WaffleChart\n            title={\"Gender\"}\n            data={_.pick(\n              _.first(raceGenderBreakdown.filter((d) => d.decade === \"2020\")),\n              [\"men\", \"women\"]\n            )}\n            colors={[COLORS.woman, COLORS.man]}\n            changeMetric={() => setMetric(\"gender\")}\n          />\n          <WaffleChart\n            title={\"Race\"}\n            data={_.pick(\n              _.first(raceGenderBreakdown.filter((d) => d.decade === \"2020\")),\n              [\"white\", \"poc\"]\n            )}\n            colors={[COLORS.poc, COLORS.white]}\n            changeMetric={() => setMetric(\"race\")}\n          />\n        </div>\n      </CrosswordWaffleWrapper>\n\n      <Scrollama onStepEnter={onStepEnter} debug offset={0.8}>\n        {copy.introSteps.map(({ text }, i) => (\n          <Step data={i} key={i}>\n            <ScrollyStep dangerouslySetInnerHTML={createMarkup(text)} />\n          </Step>\n        ))}\n      </Scrollama>\n    </div>\n  );\n};\n\nexport default IntroPuzzle;\n","import React from \"react\";\nimport copy from \"../../data/copy.json\";\nimport _ from \"lodash\";\nimport { Prose } from \"../../styles/styles.js\";\nimport { createMarkup } from \"../utils.js\";\n\nconst Intro = () => {\n  return (\n    <div>\n      {copy.introProse.map(({ value }, i) => (\n        <Prose key={i} dangerouslySetInnerHTML={createMarkup(value)} />\n      ))}\n    </div>\n  );\n};\n\nexport default Intro;\n","import React from \"react\";\nimport IntroPuzzle from \"./components/story-sections/IntroPuzzle.jsx\";\nimport Intro from \"./components/story-sections/Intro.jsx\";\nimport SlopeChart from \"./components/charts/SlopeChart.jsx\";\nimport Experiment from \"./Experiment.jsx\";\n\nfunction App() {\n  return (\n    <div>\n      <IntroPuzzle />\n      <Intro />\n      {/* <Experiment /> */}\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport { GlobalStyle } from \"./styles/styles.js\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n    <GlobalStyle />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}